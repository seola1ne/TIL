# 🧶 프로세스의 개념

#### 프로그램
: 저장 장치에 저장되어 있는 정적인 상태

#### 프로세스
: 실행을 위해 메모리에 올라온 동적인 상태

> 작성한 프로그램이 실행되면 프로세스가 된다.

<br>

### 프로그램에서 프로세스로의 전환

#### 프로세스 제어 블록(Process Control Block, PCB)

- 운영 체제가 해당 프로세스를 위해 관리하는 자료 구조
    - 프로세스 구분자 : 각 프로세스를 구분하는 구분자
    - 메모리 관련 정보 : 프로세스의 메모리 위치 정보
    - 각종 중간값 : 프로세스가 사용했던 중간값
    
    ![](https://velog.velcdn.com/images/seola1ne/post/0c192505-faf2-423b-a315-318367e3e73b/image.png)

    
<br>

### 프로세스와 프로그램의 관계

>프로그램이 프로세스가 된다 → 운영체제로부터 프로세스 제어 블록을 얻는다
프로세스가 종료된다 → 해당 프로세스 제어 블록이 폐기된다

<br>

## 프로세스의 상태

### 프로세스의 네 가지 상태

- **생성 상태** : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태

- **준비 상태** : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태

- **실행 상태** : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태

- **완료 상태** : 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 진입하는 상태(프로세스 제어블록이 사라진 상태)

![](https://velog.velcdn.com/images/seola1ne/post/3ff3fc54-84ed-417f-8440-e3960580cbc5/image.png)


- **디스패치** : 준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 CPU 스케줄러의 작업

- **타임아웃** : 프로세스가 자신에게 주어진 하나의 타임 슬라이스 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아가는 것

<br>

### 프로세스의 다섯 가지 상태

![](https://velog.velcdn.com/images/seola1ne/post/4a4f8429-29b8-4a21-a58a-97b368dde7bb/image.png)
- 프로세스의 네 가지 상태(생성, 준비, 실행, 완료) + 대기 상태

#### 생성 상태

- 프로그램이 메모리에 올라오고 운영체제로부터 프로세스 제어 블록을 할당받은 상태

- 생성된 프로세스는 바로 실행되지 X, 준비 상태에서 자기 순서를 기다리며 프로세스 제어 블록도 같이 준비 상태로 옮겨짐




#### 준비 상태

- 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태

- 프로세스 제어 블록은 준비 큐에서 기다리며 CPU 스케줄러에 의해 관리



#### 실행 상태 

- 프로세스가 CPU를 할당받아 실행되는 상태

- 실행 상태에 있는 프로세스는 자신에게 주어진 시간, 즉 타임 슬라이스 동안만 작업할 수 있음



#### 대기 상태

- 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태



#### 완료 상태

- 프로세스가 종료되는 상태

- 코드와 사용했던 데이터를 메모리에서 삭제하고 프로세스 제어 블록을 폐기

- 오류나 다른 프로세스에 의해 비정상적으로 종료되는 강제 종료를 만나면 디버깅하기 위해 종료 직전의 메모리 상태를 저장 장치로 옮김 → 코어 덤프(core dump)



#### 휴식 상태

- 프로세스가 작업을 일시적으로 쉬고 있는 상태

- 종료 상태가 X, 원할 때 다시 시작할 수 있음



#### 보류 상태

- 프로세스가 메모리에서 잠시 쫓겨난 상태

<br>

## 프로세스 제어 블록
### 프로세스 제어 블록(PCB)
>- 프로세스를 실행하는 데 필요한 정보를 보관하는 자료구조
- 프로세스는 고유의 프로세스 제어 블록을 가짐
- 프로세스 생성 시 만들어져서 프로세스가 실행을 완료하면 폐기

<br>

#### 프로세스 제어 블록의 구성(1)
- **포인터** : 준비 상태나 대기 상태의 큐를 구현할 때 사용

- **프로세스 상태** : 프로세스가 현재 어떤 상태에 있는지를 나타내는 정보

- **프로세스 구분자** : 운영체제 내에 있는 여러 프로세스를 구현하기 위한 구분자

- **프로그램 카운터** : 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값

- **프로세스 우선순위** : 프로세스의 실행 순서를 결정하는 우선순위

- **각종 레지스터 정보** : 프로세스가 실행되는 중에 사용하던 레지스터의 값

<br>


#### 프로세스 제어 블록의 구성(2)
- **메모리 관리 정보** : 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값과 한계 레지스터 값 등

- **할당된 자원 정보** : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보

- **계정 정보** : 계정 번호, CPU 할당 시간, CPU 사용 시간 등한다.

- **부모 프로세스 구분자와 자식 프로세스 구분자** : 부모 프로세스를 가리키는 PPID와 자식 프로세스를 가리키는 CPID 정보
 
 
 
 #### 포인터
 대기 상태에는 같은 입출력을 요구한 프로세스끼리 연결할 때 포인터 사용
![](https://velog.velcdn.com/images/seola1ne/post/037fb498-27bb-468a-9e7a-80f3ef87cd2f/image.png)



## 문맥 교환

### 문맥 교환
>- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
>
>
- 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고, 반대로 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅

### 문맥 교환 절차
![](https://velog.velcdn.com/images/seola1ne/post/dce9a72b-6f41-47ff-9280-addbc99b4115/image.png)

<br>

## 프로세스의 구조
![](https://velog.velcdn.com/images/seola1ne/post/a18ba4ea-5aba-4052-8261-64c17618d04c/image.png)

#### 코드 영역
 - 프로그램의 본문이 기술된 곳

 - 작성한 코드가 탑재되며 탑재된 코드는 읽기 전용으로 처리됨


#### 데이터 영역
- 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳

- 데이터는 변하는 값이기 때문에 이곳의 내용은 기본적으로 읽기와 쓰기가 가능


#### 스택 영역
- 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳

- 프로세스 내에서 함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 이 영역에 저장

- 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게는 보이지 않음

<br>

## 프로세스의 계층 구조
### 유닉스의 프로세스 계층 구조
- 유닉스의 모든 프로세스는 init 프로세스의 자식이 되어 트리 구조를 이룸
![](https://velog.velcdn.com/images/seola1ne/post/2adf65e2-4fa0-4a81-a949-12e12686e090/image.png)



### 프로세스 계층 구조의 장점
>
- 여러 작업을 동시에 처리할 수 있다.
>
- 프로세스 재사용이 용이하다.
>
>- 자원 회수가 쉽다.



### 고아 프로세스
>프로세스가 종료된 후에도 비정상적으로 남아 있는 프로세스 중 부모 프로세스가 자식보다 먼저 죽는 경우