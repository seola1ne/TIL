이번 글에서는 **스케줄링 알고리즘**에 대해 알아보고자 한다.
스케줄링 알고리즘을 이해하기 위해, [스케줄링](https://velog.io/@seola1ne/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-OS-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)에 대한 글을 먼저 읽으면 좋을 것 같다.

<hr><br>

## 🔢 스케줄링 알고리즘이란?
운영체제는 여러 개의 프로세스를 동시에 실행하고 관리하는데, 이를 위해 스케줄링 알고리즘이 사용된다. 

> 스케줄링 알고리즘은 프로세스의 우선순위, 실행 시간 등을 기반으로 프로세스들이 CPU를 사용하는 순서를 결정하는 방식이다.

시스템의 성능, 응답 시간, 처리량 등을 결정하므로 중요한 역할을 한다.

<br>

## 🧐 스케줄링 알고리즘은 언제 사용될까?
스케줄링 알고리즘은 운영체제가 프로세스를 관리할 때 사용된다.

프로세스는 CPU, 메모리, 입출력 장치 등의 시스템 자원을 사용하므로, 시스템의 성능, 안정성, 응답 시간 등에 영향을 미치기 때문이다.


운영체제는 프로세스를 관리하며 다음과 같은 상황에서 스케줄링 알고리즘을 사용한다.

>**프로세스 생성**
새로운 프로세스가 생성될 때, 스케줄링 알고리즘을 사용하여 CPU를 할당받을 순서를 결정한다.
>
**프로세스 종료**
프로세스가 종료될 때, 다음에 실행될 프로세스를 결정하기 위해 스케줄링 알고리즘을 사용한다.
>
**시스템 호출**
시스템 호출을 통해 입출력 작업을 처리하는 경우, 해당 작업이 끝날 때까지 프로세스는 대기 상태에 있어야 한다. 이때 스케줄링 알고리즘을 사용하여 대기 중인 프로세스들 중에서 CPU를 할당받을 순서를 결정한다.
>
**인터럽트 처리**
인터럽트는 예기치 않은 상황이 발생했을 때, 현재 실행 중인 프로세스를 일시 중단하고 다른 작업을 처리하는 것을 말한다. 이때 인터럽트 처리를 위한 스케줄링 알고리즘을 사용하여 현재 실행 중인 프로세스보다 우선순위가 높은 작업을 처리한다.

 
<br>

## 🗃️ 스케줄링 알고리즘의 선택 기준

### 스케줄링의 평가 기준
- **CPU 사용률**  
  - 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법
  - 프로세서를 실행상태로 항상 유지하려고 해야 한다.
  
- **처리량**
  - 단위 시간당 작업을 마친 프로세스의 수
  - 단위 시간당 완료되는 작업 수가 많도록 해야 한다.

![](https://velog.velcdn.com/images/seola1ne/post/28d8b502-5e0d-47c7-8c97-e621b5543978/image.png)

- **대기 시간**
프로세스가 생성된 후 실행되기 전까지 대기하는 시간

- **응답 시간**
첫 작업을 시작한 후 첫 번째 출력(반응)이 나오기까지의 시간

- **실행 시간**
프로세스 작업이 시작된 후 종료되기까지의 시간

- **반환 시간**
대기 시간을 포함하여 실행이 종료될 때까지의 시간


### 평균 대기 시간
모든 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 값

![](https://velog.velcdn.com/images/seola1ne/post/f71ebe3f-0e8d-421d-a8be-526dd59dd83a/image.png)

<br>

## 📚 스케줄링 알고리즘의 종류
### FCFS(First Come First Served) 스케줄링
>가장 단순한 스케줄링 알고리즘으로, **먼저 도착한 프로세스가 먼저 CPU를 할당**받는 방식이다. 따라서 프로세스의 도착 시간이 빠를수록 먼저 실행되는 경향이 있다.

![](https://velog.velcdn.com/images/seola1ne/post/88f84405-9c56-4c42-b799-4ab6fbd70d50/image.png)


이 방식은 구현이 간단하며, 프로세스의 대기 시간이나 실행 시간 등을 고려하지 않기 때문에 **공정성**이 낮고, **대기 시간**이 긴 경우가 많다.

#### FCFS 스케줄링의 성능
![](https://velog.velcdn.com/images/seola1ne/post/4f6e9e0b-0e2e-403a-8208-496a184a8a2a/image.png)

### SJF(Shortest Job First) 스케줄링
>프로세스의 실행 시간을 고려하여 CPU를 할당하는 방식이다. 실행 시간이 짧은 프로세스가 먼저 CPU를 할당받기 때문에 평균 대기 시간이 줄어들고, 처리 시간이 짧은 작업을 우선 처리할 수 있다. 

![](https://velog.velcdn.com/images/seola1ne/post/5d546669-27c6-42ec-a764-321eee6efddc/image.png)

하지만 프로세스의 실행 시간을 예측하기 어려우며, 실행 시간이 긴 프로세스의 경우 대기 시간이 길어지는 문제가 있다.

작업 시간이 길다는 이유만으로 계속 뒤로 밀려 공평성이 현저히 떨어지는데, 이를 **아사(starvation) 현상**이라 부른다.
아사 현상의 완화 방법으로는 **에이징(나이 먹기)**이 있는데, 프로세스가 양보할 수 있는 상한선을 정하는 방식이다.

#### SJF 스케줄링의 성능

![](https://velog.velcdn.com/images/seola1ne/post/a637316a-1626-4bd2-822b-ea44c6b74798/image.png)


### HRN(Highest Response-ratio Next) 스케줄링
>SJF(Shortest Job First) 스케줄링과 유사한 방식으로, 현재 대기중인 프로세스 중에서 가장 높은 응답률을 가진 프로세스에 CPU를 할당하는 방식이다.

응답률(response ratio)은 다음과 같이 계산된다.

> 응답률 = (대기 시간 + 서비스 시간) / 서비스 시간

SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘이다.

#### HRN 스케줄링의 성능
![](https://velog.velcdn.com/images/seola1ne/post/4b07b98c-efde-47a0-b3fc-7a80cc109819/image.png)

실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 **아사 현상을 완화**한다. 
대기 시간이 긴 프로세스의 우선순위를 높임으로써, **CPU를 할당받을 확률**을 높임
여전히 **공평성**이 위배되어 많이 사용되지 않음

### 라운드 로빈(Round Robin)
>각 프로세스에게 일정한 시간 할당량을 부여하고, 해당 시간이 지나면 CPU를 다음 프로세스에게 넘겨주는 방식이다. 
이를 반복하여 모든 프로세스가 처리될 때까지 계속된다.


![](https://velog.velcdn.com/images/seola1ne/post/18b2db83-6fdd-41c6-8c64-3f456f1adaaa/image.png)

#### 라운드 로빈 스케줄링의 성능
![](https://velog.velcdn.com/images/seola1ne/post/135a4ab9-1a57-431b-ae0c-3ecdaf385c20/image.png)

### SRT(Shortest Job First) 우선 스케줄링
> 기본적으로 라운드 로빈 스케줄링을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택하는 방식이다.

![](https://velog.velcdn.com/images/seola1ne/post/3cba305d-f2dd-4a4b-91e7-4f81e166db72/image.png)


#### SRT 스케줄링의 성능
![](https://velog.velcdn.com/images/seola1ne/post/83cb0cde-49d6-41e3-a924-d8ab61bdd2c9/image.png)

 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하므로 SJF 스케줄링에는 없는 작업이 추가된다.

운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않는다.

### 우선 순위(Priority) 스케줄링
> 프로세스의 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘이다.

![](https://velog.velcdn.com/images/seola1ne/post/9e259a5d-a1d2-412f-ae1e-34b82875495a/image.png)

#### 우선순위 적용
- 우선순위는 비선점형 방식과 선점형 방식에 모두 적용할 수 있음
  - (비선점형 방식) SJF 스케줄링 : 작업 시간이 짧은 프로세스에 높은 우선순위를 부여
  - (비선점형 방식) HRN 스케줄링 : 작업 시간이 짧거나 대기 시간이 긴 프로세스에 높은 우선순위를 부여
  - (선점형 방식) SRT 스케줄링 : 남은 시간이 짧은 프로세스에 높은 우선순위를 부여

####  고정 우선순위 알고리즘
- 한 번 우선순위를 부여받으면 종료될 때까지 우선순위가 고정
- 단순하게 구현할 수 있지만 시시각각 변하는 시스템의 상황을 반영하지 못해 효율성이 떨어짐

#### 변동 우선순위 알고리즘
- 일정 시간마다 우선순위가 변하여 일정 시간마다 우선순위를 새로 계산하고 이를
반영
- 복잡하지만 시스템의 상황을 반영하여 효율적인 운영 가능

준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사 현상을 일으킨다.
준비 큐에 있는 프로세스의 순서를 무시하고 프로세스의 우선순위를 매번 바꿔야 하기 때문에 오버헤드가 발생하여 시스템의 효율성을 떨어뜨린다.

### 다단계 큐(Multilevel Queue) 스케줄링
> 우선순위에 따라 준비 큐를 여러 개 사용하는 방식이다.
프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입한다. 

우선순위는 고정형 우선순위를 사용하고, 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다.

![](https://velog.velcdn.com/images/seola1ne/post/4faab068-1c5f-4c1a-b553-7376dee00978/image.png)

프로세스가 CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화한다. 우선순위가 낮아진다고 할지라도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않는다.

### 다단계 피드백 큐(Multilevel Feedback Queue) 스케줄링
> Multilevel Queue Scheduling과 유사한 방식으로, 큐를 여러 개 사용하여 스케줄링하는 방식이다. 프로세스는 첫 번째 큐에 할당되고, 실행되는 동안에는 두 번째 큐로 이동한다. 만약 두 번째 큐에서 시간 할당량을 모두 소진하면, 세 번째 큐로 이동하고 이 과정이 반복된다. 

이 방식은 프로세스의 처리 시간에 따라 우선순위를 동적으로 변화시킬 수 있어 공정성과 성능을 높일 수 있다.

![](https://velog.velcdn.com/images/seola1ne/post/a8a9e054-b797-4df2-a653-48828577f897/image.png)


<br><hr><br>

이번 글에서는 **스케줄링 알고리즘**에 대해 알아보았다.