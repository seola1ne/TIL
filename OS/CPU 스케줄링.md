<br>

# 💡 스케줄링의 개요


## CPU 스케줄러의 역할
우리 일상에서 식당 관리자는 _예약 관리, 좌석 관리, 주문 관리, 조리 순서 관리, 손님 요청 관리_ 등등 여러 일을 관리하는 역할을 맡는다.

**CPU 스케줄러**는 운영체제에서 식당 관리자의 역할을 담당하며, 
여러 프로세스의 상황을 고려하여 _CPU와 시스템 자원의 배정을 결정_한다.

![](https://velog.velcdn.com/images/seola1ne/post/711f00cd-9880-431b-a149-bf851968d00b/image.png)

식당 관리자가 조리 순서를 변경하는 모습!
CPU 스케줄러가 프로세스들의 상황을 고려하여 자원 배정을 결정하는 모습과 유사할 것이다.

<br>

## 스케줄링의 단계
#### 고수준 스케줄링
- 시스템 내의 **전체 작업 수를 조절**하는 것
- 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정
- 시스템 내에서 **동시에 실행 가능한 프로세스의 총개수**가 정해짐
- _장기 스케줄링_, _작업 스케줄링_, _승인 스케줄링_이라고도 함

#### 저수준 스케줄링
- 어떤 프로세스에 **CPU를 할당**할지, 어떤 프로세스를 **대기 상태**로 보낼지 등을 결정
- 아주 **짧은 시간**에 일어나기 때문에 _단기 스케줄링_이라고도 함


#### 중간 수준 스케줄링
- **중지**와 **활성화**로 **전체 시스템의 활성화된 프로세스 수를 조절**하여 과부하를 막음
- 일부 프로세스를 중지 상태로 옮김으로써 **나머지 프로세스가 원만하게 작동**하도록 지원
- 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할


>### 정리
**고수준 스케줄링** : 전체 시스템의 부하를 고려하여 작업을 시작할지 말지를 결정
>
**중간 수준 스케줄링** : 시스템에 과부하가 걸려서 전체 프로세스 수를 조절해야 한다면 이미 활성화된 프로세스 중 일부를 보류 상태로 보냄
>
**저수준 스케줄링** : 실제 작업을 수행

![](https://velog.velcdn.com/images/seola1ne/post/f0bdd8a5-1121-44c0-ba30-a93a9e280c6d/image.png)


## 스케줄링의 목적
>**공평성** : 모든 프로세스가 자원을 _공평하게 배정_받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 됨
>
**효율성** : 시스템 자원이 _유휴 시간_(작동 가능하나 작동되지 않는 시간) 없이 사용되도록 스케줄링을 하고, _유휴 자원_(현재 사용되지 않는 자원)을 사용하려는 프로세스에는 _우선권_을 주어야 함
>
**안정성** : _우선 순위_를 사용하여 중요 프로세스가 먼저 작동하도록 배정, 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호해야 함
>
**확장성** : 프로세스가 증가해도 시스템이 안정적으로 작동해야 함! 시스템 자원이 늘어나는 경우, 이 혜택이 시스템에 반영되게 해야 함
>
**반응 시간 보장** : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에, 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 함
>
**무한 연기 방지** : 특정 프로세스의 작업이 무한히 연기되어서는 안 됨

<br><hr><br>

# 📌 스케줄링 시 고려 사항
## 선점형 & 비선점형 스케줄링
#### 선점형 스케줄링
- 운영체제가 필요하다고 판단하면 **실행 상태에 있는 프로세스의 작업을 중단**시키고 새로운 작업을 시작할 수 있는 방식
- 하나의 프로세스가 CPU를 독점할 수 없기 때문에 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합
- 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용

선점 = 뺏어온다! (운영체제의 판단 하에 실행 중인 프로세스 작업을 중단시키고, 새로운 작업 시작)

#### 비선점형 스케줄링
- 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 **계속 실행**되는 방식
- 선점형 스케줄링보다 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적음
- CPU 사용 시간이 긴 프로세스 때문에 **CPU 사용 시간이 짧은 여러 프로세스가 오랫동안 기다리게 되어** 전체 시스템의 처리율이 떨어짐
- 과거의 일괄 작업 시스템에서 사용하던 방식

비선점 : 뺏어 오지 않는다! (어떤 프로세스가 실행 상태이면 그 프로세스가 종료될 때까지 기다림)

#### 선점형 스케줄링과 비선점형 스케줄링의 비교
![](https://velog.velcdn.com/images/seola1ne/post/9af27b86-b809-423f-95cb-640912734ff6/image.png)
여기서 오버헤드란, 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간/메모리 등을 말한다.

<br>

## 프로세스 우선 순위
> - 커널 프로세스이 우선 순위가 일반 프로세스보다 높다.
- 시스템에는 다양한 우선 순위의 프로세스가 공존하며, 우선 순위가 높은 프로세스가 CPU를 먼저, 더 오래 차지한다.

<br>

## CPU 집중 프로세스 & 입출력 집중 프로세스
#### CPU 집중 프로세스
- 수학 연산과 같이 **CPU를 많이 사용**하는 프로세스로, CPU 버스트가 많은 프로세스

#### 입출력 집중 프로세스
- 저장장치에서 데이터를 복사하는 일과 같이 **입출력을 많이 사용하**는 프로세스로 입출력 버스트가 많은 프로세스

![](https://velog.velcdn.com/images/seola1ne/post/c5571263-d2ba-49d7-b749-26d2a076d905/image.png)

#### 우선 배정
>스케줄링을 할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템의 효율이 향상

![](https://velog.velcdn.com/images/seola1ne/post/8c41262c-072b-4b0b-aee7-feaa7fa32d53/image.png)
CPU 집중 프로세스를 우선 배정했을 때보다, 입출력 집중 프로세스를 우선 배정했을 때 남아지는 시간이 적어 더 효율적인 것을 알 수 있다!

<br>

## 전면 프로세스 & 후면 프로세스
#### 전면 프로세스
- GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
- 현재 **입력**과 **출력을 사용**하는 프로세스
- **사용자와 상호작용**이 가능하여 상호작용 프로세스라고도 함

#### 후면 프로세스
- **사용자와 상호작용이 없는** 프로세스
- 사용자의 **입력 없이 작동**하기 때문에 일괄 작업 프로세스라고도 함
- 전면 프로세스의 우선순위가 후면 프로세스보다 높음

<br>

## 정리
![](https://velog.velcdn.com/images/seola1ne/post/4d91a189-76cb-4b39-a507-4f1711dd7cfd/image.png)


<br><hr><br>

# 📤 다중 큐

## 준비 상태의 다중 큐

#### 준비 상태의 다중 큐
- 프로세스는 준비 상태에 들어올 때마다 **자신의 우선순위에 해당하는 큐의 마지막에 삽입**
- CPU 스케줄러는 우선순위가 가장 높은 큐(0번 큐)의 맨 앞에 있는 프로세스 6에 CPU 할당

![](https://velog.velcdn.com/images/seola1ne/post/ecb3f963-5071-47c8-800f-57c2b9e7ecd0/image.png)

자신의 우선 순위에 따라 우선 순위 0, 1, 2 중 하나의 마지막에 삽입되는 것을 볼 수 있다.

#### 프로세스의 우선 순위를 배정하는 방식

고정 우선순위 방식
  - 운영체제가 프로세스에 **우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는** 방식
  - 프로세스가 작업하는 동안 우선순위가 변하지 않기 때문에 구현하기 쉽지만, 시스템의 상황이 시시각각 변하는데 우선순위를 고정하면 **시스템의 변화에 대응하기 어려워 작업 효율이 떨어짐**

- 변동 우선순위 방식
  - 프로세스 생성 시 부여받은 **우선순위가 프로세스 작업 중간에 변하는** 방식
  - 구현하기 어렵지만 시스템의 효율성을 높일 수 있음

## 대기 상태의 다중 큐

#### 대기 상태의 다중 큐
시스템의 효율을 높이기 위해 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아놓음

![](https://velog.velcdn.com/images/seola1ne/post/fa715ff4-00d8-433f-b533-8c9e64862438/image.png)

`HDD`, `CD-ROM`, `LAN` 과 같이 같은 입출력을 요구하는 PCB끼리 모아져 있는 것을 볼 수 있다.

#### 다중 큐 비교
>##### 준비 큐
 한 번에 하나의 프로세스를 꺼내어 CPU를 할당
>
##### 대기 큐
 - 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮김
- 대기 큐에서 동시에 끝나는 인터럽트를 처리하기 위해 인터럽트 벡터라는
자료 구조 사용


#### 프로세스 상태와 다중 큐
![](https://velog.velcdn.com/images/seola1ne/post/a553505a-28df-4d4f-b290-3620fb44caa6/image.png)


<br><hr><br>

이번 글에서는 운영체제의 **CPU 스케줄링**에 대해 알아보았다. 
다음 글에서는 **스케줄링 알고리즘**에 대해 알아보자!