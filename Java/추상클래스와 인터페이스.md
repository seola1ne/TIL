# 1. 추상 클래스

상속 관계에 있는 클래스 중에서 **상위 클래스에서는 특별한 구현 없이** 사용하고자 하는 메소드만 기술하고 **구체적인 구현은 하위 클래스에서** 하도록 할 수 있다.

이때 사용하는 것이 추상 클래스로, 구체적인 내용 기술 없이 모양만 갖춘 클래스이다.

추상 클래스는 `abstract` 키워드를 사용하여 표시하고 추상 클래스 안에는 추상 메소드를 가진다.

**예시**

> 모든 도형은 둘레와 면적을 구할 수 있다고 할 때, 학생들에게 특정 도형 클래스를 만들어 둘레와 면적을 반드시 구하게 하려 함 → 도형 클래스에 둘레와 면적을 구하는 메소드를 반드시 작성해야 하기 때문에, 해당 메소드들을 추상 클래스로 제공
> 

> 탑승객(), 적재량() 추상 메소드를 가진 추상 클래스 Ship을 이용해 학생 개개인이 배의 이름과 최대 탑승 인원과 최대 적재량은 출력하는 클래스 구현
> 

## 1-1. 추상 클래스

추상 클래스는 추상 메소드를 가진 클래스로 추상 클래스는 `new` 연산자로 객체 생성할 수 없다. 

따라서 추상 클래스의 추상 메소드는 **자신이 직접 이용하지 못하고** 하위 클래스에서 이 메소드를 상속받아 구현하여 사용해야 한다.

**형식**

```java
abstract class 클래스명 {
	// 추상 메소드 선언
}
```

추상 클래스의 추상 메소드는 반드시 오버라이딩되어야 하기 때문에 **하위 클래스들이 특정 메소드를 반드시 구현하도록 강제**할 수 있고, 만약 추상 메소드를 오버라이딩하지 않으면 상속받는 클래스는 자동으로 추상 클래스가 된다.

※ 추상 클래스는 일반 메소드와 추상 메소드를 모두 포함할 수 있다.

## 1-2. 추상 메소드

추상 메소드는 메소드의 이름 앞에 `abstract`가 있으며, 구현 내용이 없는 메소드로 이를 상속받는 하위 클래스들이 반드시 재정의해서 사용해야 하는 메소드들을 지정하고자 할 때 사용한다.

따라서 추상 메소드는 **반드시 오버라이딩** 되어야 한다.

**형식**

```java
접근 제어자 abstract 반환형 메소드명();
```

메소드의 구현 내용({})이 없고, 메소드 다음에 세미콜론을 붙인다.

<hr>

# 2. 인터페이스

자바는 다중 상속을 지원하지 않는 반면, **다중 상속과 유사**한 기능이 있는 **인터페이스**를 제공한다.

**예시**

> 어린이 클래스 정의 시 아버지 클래스와 어머니 클래스를 동시에 상속받을 수 X
>
> → 아버지 클래스로부터 상속받고, 어머니를 인터페이스로 정의하여 어린이 클래스에서 구현! 다양한 기능 부가적으로 사용 가능
> 

인터페이스는 모든 메소드가 추상 메소드이며, 데이터는 `final` `static` 변수만을 가지는 특별한 형태의 클래스이다.

인터페이스는 클래스가 아니기 때문에 **객체가 가질 수 있는 메소드 이름만을 명시**하고 실제 기능은 인터페이스를 상속받아 구현하는 클래스에서 기술해야 한다. 즉, 인터페이스를 적용한 클래스는 인터페이스에서 선언된 메소드를 모두 구현해 주어야 한다. 만일 **해당 메소드를 구현하지 않은 클래스는 추상 클래스가 된다.**

**형식**

```java
public interface 인터페이스명 {
	public 메소드 이름(인자들);
}
```

**인터페이스를 클래스에 구현하는 형식**

```java
class 클래스명 implements 인터페이스명 {
	......
}
```

## 2-1. 인터페이스 상속

인터페이스는 일반 클래스처럼 또 다른 인터페이스를 상속받을 수 있다.

**형식**

```java
public interface 인터페이스 이름 extends 상위 인터페이스 이름
```